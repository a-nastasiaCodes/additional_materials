# Оценка сложности алгоритмов

## **Временная сложность (Time Complexity)**
Оценивает время работы алгоритма в зависимости от размера входных данных.

### Основные классы сложности:
- **O(1)** - постоянная (доступ к элементу массива)
- **O(log n)** - логарифмическая (бинарный поиск)
- **O(n)** - линейная (поиск в неотсортированном массиве)
- **O(n log n)** - линейно-логарифмическая (быстрая сортировка)
- **O(n²)** - квадратичная (пузырьковая сортировка)
- **O(2ⁿ)** - экспоненциальная (задача коммивояжера)

## **Пространственная сложность (Space Complexity)**
Оценивает объем памяти, необходимый алгоритму.

### Примеры:
- **O(1)** - сортировка на месте
- **O(n)** - требуется дополнительный массив
- **O(n²)** - матрица смежности графа

## **Правила анализа:**

### 1. Отбрасываем константы**
```python
# O(n), а не O(2n)
def example(arr):
    for i in arr:    # O(n)
        print(i)
    for i in arr:    # O(n)
        print(i)
```

### 2. Берем наибольшую сложность**
```python
# O(n²), а не O(n + n²)
def example(arr):
    for i in arr:        # O(n)
        print(i)
    for i in arr:        # O(n²)
        for j in arr:
            print(i, j)
```

### 3. Умножаем вложенные циклы**
```python
# O(n * m)
def example(n, m):
    for i in range(n):      # O(n)
        for j in range(m):  # O(m)
            print(i, j)
```

## **Практические примеры:**

### O(1) - постоянная сложность
```python
def get_first(arr):
    return arr[0]  # Всегда одна операция
```

### O(n) - линейная сложность
```python
def find_max(arr):
    max_val = arr[0]           # O(1)
    for num in arr:            # O(n)
        if num > max_val:
            max_val = num
    return max_val             # O(1)
# Итого: O(n)
```

### O(n²) - квадратичная сложность
```python
def bubble_sort(arr):
    n = len(arr)
    for i in range(n):         # O(n)
        for j in range(n-1):   # O(n)
            if arr[j] > arr[j+1]:
                arr[j], arr[j+1] = arr[j+1], arr[j]
# Итого: O(n²)
```

### O(log n) - логарифмическая сложность
```python
def binary_search(arr, target):
    left, right = 0, len(arr)-1
    while left <= right:           # O(log n)
        mid = (left + right) // 2
        if arr[mid] == target:
            return mid
        elif arr[mid] < target:
            left = mid + 1
        else:
            right = mid - 1
    return -1
```

## **Память:**
- **O(1)** - алгоритм использует фиксированное количество памяти
- **O(n)** - память растет линейно с размером входных данных
- **O(n²)** - память растет квадратично
